@use "sass:math";

$tau: math.$pi * 2;

// some defaults
$perspective: 40vh;
$y-scale: 10vh;
$z-scale: 10vh;
$turns: 1turn;

// set these to the styles you want for your `active` and `inactive` spans
//
// from a client, something like:
//   rotator.$activated-styles: (color: red, font-weight: bold);
//
// note that this is a *map* of values, not a CSS block
$activated-styles: none;
$deactivated-styles: none;

// these two get populated from the above
@mixin activated {
  @each $key, $value in $activated-styles {
    #{$key}: #{$value};
  }
}

@mixin deactivated {
  @each $key, $value in $deactivated-styles {
    #{$key}: #{$value};
  }
}

// how many radians for `$index` (out of 100)
@function radians($index) {
  @return (math.div($tau, 100) * $index) % $tau;
}

// the y-value for `$index` (out of 100)
//
// with no `$scale` supplied, the result is *unitless*
// `$up-first` means `y` goes 0 -> 1 -> 0 -> -1
@function y-value($index, $scale: 1, $up-first: true) {
  $val: math.sin(radians($index)) * $scale;
  @if $up-first {
    $val: 0 - $val;
  }
  @return $val;
}

// the z-value for `$index` (out of 100)
//
// with no `$scale` supplied, the result is *unitless*
// `$offset` pulls the origin forwards (needs units)
// `$start-at-back` means `z` goes -1 -> 0 -> 1 -> 0
@function z-value($index, $scale: 1, $offset: 0, $start-at-back: true) {
  $val: (math.cos(radians($index)) * $scale);
  @if $start-at-back {
    $val: 0 - $val;
  }
  @return $val + $offset;
}

// how much to rotate for `$index`
//
// with no `$turns` supplied, the result is *unitless*
// `$offset` is added to `$index` to modify the rotation relative to the motion
// `$up-first` means this follows the curve of the default motion for the `y` and `z` above
@function rotation($index, $turns: 1, $offset: 0, $up-first: true) {
  $val: math.div($index + $offset, 100) * $turns;
  @if $up-first {
    $val: 0 - $val;
  }
  @return $val;
}

// select which mixin to include in the frame for `$index` and `$direction`
@mixin select-include($index, $direction) {
  @if $direction == "in" {
    @if $index == 0 {
      @include deactivated;
    }
    @if $index == 100 {
      @include activated;
    }
  }

  @if $direction == "out" {
    @if $index == 0 {
      @include activated;
    }
    @if $index == 100 {
      @include deactivated;
    }
  }
}

// generate one frame of animation for `$index` and `$direction`
@mixin one-frame($index, $direction) {
  transform: perspective($perspective)
    translateY(y-value($index, $scale: $y-scale))
    translateZ(z-value($index, $scale: $z-scale, $offset: $z-scale))
    rotateX(rotation($index, $turns: $turns));

  @include select-include($index, $direction);
}

// generate a set of frames for `$direction`
//
// `$step-size` should divide 100 cleanly or your animation will be janky
//
// I have no fucking idea how to test this
@mixin frame-generator($direction, $step-size: 1) {
  @for $i from 0 through 100 {
    @if $i % $step-size == 0 {
      #{$i}% {
        @include one-frame($i, $direction);
      }
    }
  }
}

// generate two @keyframe sets, `rotate-in` and `rotate-out`
//
// `rotate-in` should be applied to things that have just become `active`
// `rotate-out` should be applied to things that have just become `inactive`
@mixin make-frames {
  @each $anim in "in", "out" {
    @keyframes rotate-#{$anim} {
      @include frame-generator($anim);
    }
  }
}
